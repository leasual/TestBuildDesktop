// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'group_attribute.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

GroupAttribute _$GroupAttributeFromJson(Map<String, dynamic> json) {
  return _GroupAttribute.fromJson(json);
}

/// @nodoc
mixin _$GroupAttribute {
  Action? get action => throw _privateConstructorUsedError;
  List<dynamic>? get devicemembership => throw _privateConstructorUsedError;
  String? get etag => throw _privateConstructorUsedError;
  bool? get hidden => throw _privateConstructorUsedError;
  String? get id => throw _privateConstructorUsedError;
  List<String>? get lights => throw _privateConstructorUsedError;
  List<String>? get lightsequence => throw _privateConstructorUsedError;
  List<String>? get multideviceids => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  List<Scene>? get scenes => throw _privateConstructorUsedError;
  int? get state => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GroupAttributeCopyWith<GroupAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupAttributeCopyWith<$Res> {
  factory $GroupAttributeCopyWith(
          GroupAttribute value, $Res Function(GroupAttribute) then) =
      _$GroupAttributeCopyWithImpl<$Res, GroupAttribute>;
  @useResult
  $Res call(
      {Action? action,
      List<dynamic>? devicemembership,
      String? etag,
      bool? hidden,
      String? id,
      List<String>? lights,
      List<String>? lightsequence,
      List<String>? multideviceids,
      String? name,
      List<Scene>? scenes,
      int? state});

  $ActionCopyWith<$Res>? get action;
}

/// @nodoc
class _$GroupAttributeCopyWithImpl<$Res, $Val extends GroupAttribute>
    implements $GroupAttributeCopyWith<$Res> {
  _$GroupAttributeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? action = freezed,
    Object? devicemembership = freezed,
    Object? etag = freezed,
    Object? hidden = freezed,
    Object? id = freezed,
    Object? lights = freezed,
    Object? lightsequence = freezed,
    Object? multideviceids = freezed,
    Object? name = freezed,
    Object? scenes = freezed,
    Object? state = freezed,
  }) {
    return _then(_value.copyWith(
      action: freezed == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as Action?,
      devicemembership: freezed == devicemembership
          ? _value.devicemembership
          : devicemembership // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      etag: freezed == etag
          ? _value.etag
          : etag // ignore: cast_nullable_to_non_nullable
              as String?,
      hidden: freezed == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      lights: freezed == lights
          ? _value.lights
          : lights // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lightsequence: freezed == lightsequence
          ? _value.lightsequence
          : lightsequence // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      multideviceids: freezed == multideviceids
          ? _value.multideviceids
          : multideviceids // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      scenes: freezed == scenes
          ? _value.scenes
          : scenes // ignore: cast_nullable_to_non_nullable
              as List<Scene>?,
      state: freezed == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ActionCopyWith<$Res>? get action {
    if (_value.action == null) {
      return null;
    }

    return $ActionCopyWith<$Res>(_value.action!, (value) {
      return _then(_value.copyWith(action: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_GroupAttributeCopyWith<$Res>
    implements $GroupAttributeCopyWith<$Res> {
  factory _$$_GroupAttributeCopyWith(
          _$_GroupAttribute value, $Res Function(_$_GroupAttribute) then) =
      __$$_GroupAttributeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Action? action,
      List<dynamic>? devicemembership,
      String? etag,
      bool? hidden,
      String? id,
      List<String>? lights,
      List<String>? lightsequence,
      List<String>? multideviceids,
      String? name,
      List<Scene>? scenes,
      int? state});

  @override
  $ActionCopyWith<$Res>? get action;
}

/// @nodoc
class __$$_GroupAttributeCopyWithImpl<$Res>
    extends _$GroupAttributeCopyWithImpl<$Res, _$_GroupAttribute>
    implements _$$_GroupAttributeCopyWith<$Res> {
  __$$_GroupAttributeCopyWithImpl(
      _$_GroupAttribute _value, $Res Function(_$_GroupAttribute) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? action = freezed,
    Object? devicemembership = freezed,
    Object? etag = freezed,
    Object? hidden = freezed,
    Object? id = freezed,
    Object? lights = freezed,
    Object? lightsequence = freezed,
    Object? multideviceids = freezed,
    Object? name = freezed,
    Object? scenes = freezed,
    Object? state = freezed,
  }) {
    return _then(_$_GroupAttribute(
      action: freezed == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as Action?,
      devicemembership: freezed == devicemembership
          ? _value._devicemembership
          : devicemembership // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      etag: freezed == etag
          ? _value.etag
          : etag // ignore: cast_nullable_to_non_nullable
              as String?,
      hidden: freezed == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      lights: freezed == lights
          ? _value._lights
          : lights // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lightsequence: freezed == lightsequence
          ? _value._lightsequence
          : lightsequence // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      multideviceids: freezed == multideviceids
          ? _value._multideviceids
          : multideviceids // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      scenes: freezed == scenes
          ? _value._scenes
          : scenes // ignore: cast_nullable_to_non_nullable
              as List<Scene>?,
      state: freezed == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GroupAttribute implements _GroupAttribute {
  const _$_GroupAttribute(
      {this.action,
      final List<dynamic>? devicemembership,
      this.etag,
      this.hidden,
      this.id,
      final List<String>? lights,
      final List<String>? lightsequence,
      final List<String>? multideviceids,
      this.name,
      final List<Scene>? scenes,
      this.state})
      : _devicemembership = devicemembership,
        _lights = lights,
        _lightsequence = lightsequence,
        _multideviceids = multideviceids,
        _scenes = scenes;

  factory _$_GroupAttribute.fromJson(Map<String, dynamic> json) =>
      _$$_GroupAttributeFromJson(json);

  @override
  final Action? action;
  final List<dynamic>? _devicemembership;
  @override
  List<dynamic>? get devicemembership {
    final value = _devicemembership;
    if (value == null) return null;
    if (_devicemembership is EqualUnmodifiableListView)
      return _devicemembership;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? etag;
  @override
  final bool? hidden;
  @override
  final String? id;
  final List<String>? _lights;
  @override
  List<String>? get lights {
    final value = _lights;
    if (value == null) return null;
    if (_lights is EqualUnmodifiableListView) return _lights;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _lightsequence;
  @override
  List<String>? get lightsequence {
    final value = _lightsequence;
    if (value == null) return null;
    if (_lightsequence is EqualUnmodifiableListView) return _lightsequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _multideviceids;
  @override
  List<String>? get multideviceids {
    final value = _multideviceids;
    if (value == null) return null;
    if (_multideviceids is EqualUnmodifiableListView) return _multideviceids;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? name;
  final List<Scene>? _scenes;
  @override
  List<Scene>? get scenes {
    final value = _scenes;
    if (value == null) return null;
    if (_scenes is EqualUnmodifiableListView) return _scenes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? state;

  @override
  String toString() {
    return 'GroupAttribute(action: $action, devicemembership: $devicemembership, etag: $etag, hidden: $hidden, id: $id, lights: $lights, lightsequence: $lightsequence, multideviceids: $multideviceids, name: $name, scenes: $scenes, state: $state)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GroupAttribute &&
            (identical(other.action, action) || other.action == action) &&
            const DeepCollectionEquality()
                .equals(other._devicemembership, _devicemembership) &&
            (identical(other.etag, etag) || other.etag == etag) &&
            (identical(other.hidden, hidden) || other.hidden == hidden) &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._lights, _lights) &&
            const DeepCollectionEquality()
                .equals(other._lightsequence, _lightsequence) &&
            const DeepCollectionEquality()
                .equals(other._multideviceids, _multideviceids) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._scenes, _scenes) &&
            (identical(other.state, state) || other.state == state));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      action,
      const DeepCollectionEquality().hash(_devicemembership),
      etag,
      hidden,
      id,
      const DeepCollectionEquality().hash(_lights),
      const DeepCollectionEquality().hash(_lightsequence),
      const DeepCollectionEquality().hash(_multideviceids),
      name,
      const DeepCollectionEquality().hash(_scenes),
      state);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GroupAttributeCopyWith<_$_GroupAttribute> get copyWith =>
      __$$_GroupAttributeCopyWithImpl<_$_GroupAttribute>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GroupAttributeToJson(
      this,
    );
  }
}

abstract class _GroupAttribute implements GroupAttribute {
  const factory _GroupAttribute(
      {final Action? action,
      final List<dynamic>? devicemembership,
      final String? etag,
      final bool? hidden,
      final String? id,
      final List<String>? lights,
      final List<String>? lightsequence,
      final List<String>? multideviceids,
      final String? name,
      final List<Scene>? scenes,
      final int? state}) = _$_GroupAttribute;

  factory _GroupAttribute.fromJson(Map<String, dynamic> json) =
      _$_GroupAttribute.fromJson;

  @override
  Action? get action;
  @override
  List<dynamic>? get devicemembership;
  @override
  String? get etag;
  @override
  bool? get hidden;
  @override
  String? get id;
  @override
  List<String>? get lights;
  @override
  List<String>? get lightsequence;
  @override
  List<String>? get multideviceids;
  @override
  String? get name;
  @override
  List<Scene>? get scenes;
  @override
  int? get state;
  @override
  @JsonKey(ignore: true)
  _$$_GroupAttributeCopyWith<_$_GroupAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

Action _$ActionFromJson(Map<String, dynamic> json) {
  return _Action.fromJson(json);
}

/// @nodoc
mixin _$Action {
  int? get bri => throw _privateConstructorUsedError;
  int? get ct => throw _privateConstructorUsedError;
  String? get effect => throw _privateConstructorUsedError;
  int? get hue => throw _privateConstructorUsedError;
  bool? get on => throw _privateConstructorUsedError;
  int? get sat => throw _privateConstructorUsedError;
  List<int>? get xy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ActionCopyWith<Action> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ActionCopyWith<$Res> {
  factory $ActionCopyWith(Action value, $Res Function(Action) then) =
      _$ActionCopyWithImpl<$Res, Action>;
  @useResult
  $Res call(
      {int? bri,
      int? ct,
      String? effect,
      int? hue,
      bool? on,
      int? sat,
      List<int>? xy});
}

/// @nodoc
class _$ActionCopyWithImpl<$Res, $Val extends Action>
    implements $ActionCopyWith<$Res> {
  _$ActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bri = freezed,
    Object? ct = freezed,
    Object? effect = freezed,
    Object? hue = freezed,
    Object? on = freezed,
    Object? sat = freezed,
    Object? xy = freezed,
  }) {
    return _then(_value.copyWith(
      bri: freezed == bri
          ? _value.bri
          : bri // ignore: cast_nullable_to_non_nullable
              as int?,
      ct: freezed == ct
          ? _value.ct
          : ct // ignore: cast_nullable_to_non_nullable
              as int?,
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as String?,
      hue: freezed == hue
          ? _value.hue
          : hue // ignore: cast_nullable_to_non_nullable
              as int?,
      on: freezed == on
          ? _value.on
          : on // ignore: cast_nullable_to_non_nullable
              as bool?,
      sat: freezed == sat
          ? _value.sat
          : sat // ignore: cast_nullable_to_non_nullable
              as int?,
      xy: freezed == xy
          ? _value.xy
          : xy // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ActionCopyWith<$Res> implements $ActionCopyWith<$Res> {
  factory _$$_ActionCopyWith(_$_Action value, $Res Function(_$_Action) then) =
      __$$_ActionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? bri,
      int? ct,
      String? effect,
      int? hue,
      bool? on,
      int? sat,
      List<int>? xy});
}

/// @nodoc
class __$$_ActionCopyWithImpl<$Res>
    extends _$ActionCopyWithImpl<$Res, _$_Action>
    implements _$$_ActionCopyWith<$Res> {
  __$$_ActionCopyWithImpl(_$_Action _value, $Res Function(_$_Action) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bri = freezed,
    Object? ct = freezed,
    Object? effect = freezed,
    Object? hue = freezed,
    Object? on = freezed,
    Object? sat = freezed,
    Object? xy = freezed,
  }) {
    return _then(_$_Action(
      bri: freezed == bri
          ? _value.bri
          : bri // ignore: cast_nullable_to_non_nullable
              as int?,
      ct: freezed == ct
          ? _value.ct
          : ct // ignore: cast_nullable_to_non_nullable
              as int?,
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as String?,
      hue: freezed == hue
          ? _value.hue
          : hue // ignore: cast_nullable_to_non_nullable
              as int?,
      on: freezed == on
          ? _value.on
          : on // ignore: cast_nullable_to_non_nullable
              as bool?,
      sat: freezed == sat
          ? _value.sat
          : sat // ignore: cast_nullable_to_non_nullable
              as int?,
      xy: freezed == xy
          ? _value._xy
          : xy // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Action implements _Action {
  const _$_Action(
      {this.bri,
      this.ct,
      this.effect,
      this.hue,
      this.on,
      this.sat,
      final List<int>? xy})
      : _xy = xy;

  factory _$_Action.fromJson(Map<String, dynamic> json) =>
      _$$_ActionFromJson(json);

  @override
  final int? bri;
  @override
  final int? ct;
  @override
  final String? effect;
  @override
  final int? hue;
  @override
  final bool? on;
  @override
  final int? sat;
  final List<int>? _xy;
  @override
  List<int>? get xy {
    final value = _xy;
    if (value == null) return null;
    if (_xy is EqualUnmodifiableListView) return _xy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Action(bri: $bri, ct: $ct, effect: $effect, hue: $hue, on: $on, sat: $sat, xy: $xy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Action &&
            (identical(other.bri, bri) || other.bri == bri) &&
            (identical(other.ct, ct) || other.ct == ct) &&
            (identical(other.effect, effect) || other.effect == effect) &&
            (identical(other.hue, hue) || other.hue == hue) &&
            (identical(other.on, on) || other.on == on) &&
            (identical(other.sat, sat) || other.sat == sat) &&
            const DeepCollectionEquality().equals(other._xy, _xy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, bri, ct, effect, hue, on, sat,
      const DeepCollectionEquality().hash(_xy));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ActionCopyWith<_$_Action> get copyWith =>
      __$$_ActionCopyWithImpl<_$_Action>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ActionToJson(
      this,
    );
  }
}

abstract class _Action implements Action {
  const factory _Action(
      {final int? bri,
      final int? ct,
      final String? effect,
      final int? hue,
      final bool? on,
      final int? sat,
      final List<int>? xy}) = _$_Action;

  factory _Action.fromJson(Map<String, dynamic> json) = _$_Action.fromJson;

  @override
  int? get bri;
  @override
  int? get ct;
  @override
  String? get effect;
  @override
  int? get hue;
  @override
  bool? get on;
  @override
  int? get sat;
  @override
  List<int>? get xy;
  @override
  @JsonKey(ignore: true)
  _$$_ActionCopyWith<_$_Action> get copyWith =>
      throw _privateConstructorUsedError;
}

Scene _$SceneFromJson(Map<String, dynamic> json) {
  return _Scene.fromJson(json);
}

/// @nodoc
mixin _$Scene {
  String? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SceneCopyWith<Scene> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SceneCopyWith<$Res> {
  factory $SceneCopyWith(Scene value, $Res Function(Scene) then) =
      _$SceneCopyWithImpl<$Res, Scene>;
  @useResult
  $Res call({String? id, String? name});
}

/// @nodoc
class _$SceneCopyWithImpl<$Res, $Val extends Scene>
    implements $SceneCopyWith<$Res> {
  _$SceneCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SceneCopyWith<$Res> implements $SceneCopyWith<$Res> {
  factory _$$_SceneCopyWith(_$_Scene value, $Res Function(_$_Scene) then) =
      __$$_SceneCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? id, String? name});
}

/// @nodoc
class __$$_SceneCopyWithImpl<$Res> extends _$SceneCopyWithImpl<$Res, _$_Scene>
    implements _$$_SceneCopyWith<$Res> {
  __$$_SceneCopyWithImpl(_$_Scene _value, $Res Function(_$_Scene) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_Scene(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Scene implements _Scene {
  const _$_Scene({this.id, this.name});

  factory _$_Scene.fromJson(Map<String, dynamic> json) =>
      _$$_SceneFromJson(json);

  @override
  final String? id;
  @override
  final String? name;

  @override
  String toString() {
    return 'Scene(id: $id, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Scene &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SceneCopyWith<_$_Scene> get copyWith =>
      __$$_SceneCopyWithImpl<_$_Scene>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SceneToJson(
      this,
    );
  }
}

abstract class _Scene implements Scene {
  const factory _Scene({final String? id, final String? name}) = _$_Scene;

  factory _Scene.fromJson(Map<String, dynamic> json) = _$_Scene.fromJson;

  @override
  String? get id;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_SceneCopyWith<_$_Scene> get copyWith =>
      throw _privateConstructorUsedError;
}
